<h1 id="семантическое-версионирование-200"><a class="anchor-link" href="#семантическое-версионирование-200"></a>Семантическое Версионирование 2.0.0</h1>

<h2 id="кратко"><a class="anchor-link" href="#кратко"></a>Кратко</h2>

<p>Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:</p>

<ol>
  <li>МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.</li>
  <li>МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной
совместимости.</li>
  <li>ПАТЧ-версию, когда вы делаете обратно совместимые исправления.</li>
</ol>

<p>Дополнительные обозначения для предрелизных и билд-метаданных возможны как
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.</p>

<h2 id="вступление"><a class="anchor-link" href="#вступление"></a>Вступление</h2>

<p>В мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.</p>

<p>В системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).</p>

<p>В качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы этот API был ясным и точным. Однажды определив публичный API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (мажорная, минорная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч-версию, обратно совместимые добавления/изменения API
увеличивают минорную версию и обратно несовместимые изменения API увеличивают
мажорную версию.</p>

<p>Я называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.</p>

<h2 id="спецификация-семантического-версионирования-semver"><a class="anchor-link" href="#спецификация-семантического-версионирования-semver"></a>Спецификация Семантического Версионирования (SemVer)</h2>

<p>Слова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a>.</p>

<ol>
  <li id="spec-item-1">
    <a class="anchor-link" href="#spec-item-1"></a><p>ПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.</p>
  </li>
  <li id="spec-item-2">
    <a class="anchor-link" href="#spec-item-2"></a><p>Обычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 -&gt;1.10.0 -&gt; 1.11.0.</p>
  </li>
  <li id="spec-item-3">
    <a class="anchor-link" href="#spec-item-3"></a><p>После релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.</p>
  </li>
  <li id="spec-item-4">
    <a class="anchor-link" href="#spec-item-4"></a><p>Мажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.</p>
  </li>
  <li id="spec-item-5">
    <a class="anchor-link" href="#spec-item-5"></a><p>Версия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.</p>
  </li>
  <li id="spec-item-6">
    <a class="anchor-link" href="#spec-item-6"></a><p>Патч-версия  Z (x.y.Z | x &gt; 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.</p>
  </li>
  <li id="spec-item-7">
    <a class="anchor-link" href="#spec-item-7"></a><p>Минорная версия (x.Y.z | x &gt; 0) ДОЛЖНА быть увеличена, если в публичном API
представлена новая обратно совместимая функциональность. Версия ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревшая (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.</p>
  </li>
  <li id="spec-item-8">
    <a class="anchor-link" href="#spec-item-8"></a><p>Мажорная версия X (X.y.z | X &gt; 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.</p>
  </li>
  <li id="spec-item-9">
    <a class="anchor-link" href="#spec-item-9"></a><p>Предрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.</p>
  </li>
  <li id="spec-item-10">
    <a class="anchor-link" href="#spec-item-10"></a><p>Сборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.</p>
  </li>
  <li id="spec-item-11">
    <a class="anchor-link" href="#spec-item-11"></a><p>Приоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha &lt; 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt;
1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0.</p>
  </li>
</ol>

<h2 id="зачем-использовать-семантическое-версионирование"><a class="anchor-link" href="#зачем-использовать-семантическое-версионирование"></a>Зачем использовать семантическое версионирование?</h2>

<p>Это не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.</p>

<p>Простой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональность версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.</p>

<p>Как ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.</p>

<p>Если это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.</p>

<h2 id="faq"><a class="anchor-link" href="#faq"></a>FAQ</h2>

<h3 id="что-я-должен-делать-с-ревизиями-в-0yz-на-начальной-стадии-разработки"><a class="anchor-link" href="#что-я-должен-делать-с-ревизиями-в-0yz-на-начальной-стадии-разработки"></a>Что я должен делать с ревизиями в 0.y.z на начальной стадии разработки?</h3>

<p>Самое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию
для каждого последующего релиза.</p>

<h3 id="как-я-узнаю-когда-пора-делать-релиз-100"><a class="anchor-link" href="#как-я-узнаю-когда-пора-делать-релиз-100"></a>Как я узнаю, когда пора делать релиз 1.0.0?</h3>

<p>Если ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.</p>

<h3 id="не-препятствует-ли-это-быстрой-разработке-и-коротким-итерациям"><a class="anchor-link" href="#не-препятствует-ли-это-быстрой-разработке-и-коротким-итерациям"></a>Не препятствует ли это быстрой разработке и коротким итерациям?</h3>

<p>Мажорная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.</p>

<h3 id="даже-если-малейшие-обратно-несовместимые-изменения-в-публичном-api-требуют-выпуска-новой-главной-версии-не-закончится-ли-это-тем-что-очень-скоро-версия-станет-4200"><a class="anchor-link" href="#даже-если-малейшие-обратно-несовместимые-изменения-в-публичном-api-требуют-выпуска-новой-главной-версии-не-закончится-ли-это-тем-что-очень-скоро-версия-станет-4200"></a>Даже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?</h3>

<p>Это вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.</p>

<h3 id="документирование-всего-api--слишком-много-работы"><a class="anchor-link" href="#документирование-всего-api--слишком-много-работы"></a>Документирование всего API — слишком много работы!</h3>

<p>Это ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.</p>

<h3 id="что-мне-делать-если-я-случайно-зарелизил-обратно-несовместимые-изменения-как-минорную-версию"><a class="anchor-link" href="#что-мне-делать-если-я-случайно-зарелизил-обратно-несовместимые-изменения-как-минорную-версию"></a>Что мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?</h3>

<p>Как только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую минорную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.</p>

<h3 id="что-я-должен-делать-если-я-обновляю-свои-собственные-зависимости-без-изменения-публичного-api"><a class="anchor-link" href="#что-я-должен-делать-если-я-обновляю-свои-собственные-зависимости-без-изменения-публичного-api"></a>Что я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?</h3>

<p>Это можно рассматривать как совместимые изменения, так как они не влияют на
публичный API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
минорного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается минорная версия.</p>

<h3 id="что-если-я-нечаянно-изменил-публичный-api-в-несоответствии-с-изменением-номера-версии-те-код-содержит-обратно-несовместимые-изменения-в-патч-релизе"><a class="anchor-link" href="#что-если-я-нечаянно-изменил-публичный-api-в-несоответствии-с-изменением-номера-версии-те-код-содержит-обратно-несовместимые-изменения-в-патч-релизе"></a>Что если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?</h3>

<p>На ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.</p>

<h3 id="что-делать-с-устаревшей-функциональностью"><a class="anchor-link" href="#что-делать-с-устаревшей-функциональностью"></a>Что делать с устаревшей функциональностью?</h3>

<p>Объявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением минорной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
минорный релиз, содержащий объявление функциональности устаревшей, чтобы
пользователи могли плавно перейти на новый API.</p>

<h3 id="есть-ли-в-semver-лимиты-на-длину-строки-версии"><a class="anchor-link" href="#есть-ли-в-semver-лимиты-на-длину-строки-версии"></a>Есть ли в SemVer лимиты на длину строки версии?</h3>

<p>Нет, но руководствуйтесь здравым смыслом. 255 символов в строке версии, пожалуй,
перебор. Кроме того, определенные системы могут предъявлять свои
собственные ограничения на размер строки.</p>

<h2 id="об-авторе"><a class="anchor-link" href="#об-авторе"></a>Об авторе</h2>

<p>Авторство спецификаций Семантического Версионирования принадлежит
<a href="http://tom.preston-werner.com">Тому Престон-Вернеру</a>, основателю Gravatars и
соучредителю GitHub.</p>

<p>Если вы хотите оставить отзыв, пожалуйста, <a href="https://github.com/semver/semver/issues">создайте запрос на
GitHub</a>.</p>

<h2 id="лицензия"><a class="anchor-link" href="#лицензия"></a>Лицензия</h2>

<p><a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons — CC BY 3.0</a></p>